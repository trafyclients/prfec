// 'use client';

// import { useState, useEffect, useRef } from 'react';
// import '@styles/ai/BetaAi.css';
// import Image from 'next/image';
// import Hover from '@public/Images/ai/hover.svg';
// import NoHover from '@public/Images/ai/nohover.svg';
// import copy from '@public/Images/ai/copy.svg';
// import refresh from '@public/Images/ai/refresh.svg';

// export default function PuterChat() {
//   const [messages, setMessages] = useState([]);
//   const [input, setInput] = useState('');
//   const [isTyping, setIsTyping] = useState(false);
//   const [buttonHl, setButtonHl] = useState(false);
//   const [isCopied, setIsCopied] = useState(false);
//   const [copyHover, setCopyHover] = useState(false);
//   const messagesEndRef = useRef(null);
//   const chatContainerRef = useRef(null);

//   const handleInputChange = (event) => {
//     const newInput = event.target.value;
//     setInput(newInput);
//     setButtonHl(newInput.trim() !== ''); // Highlight button if input isn't empty
//   };

//   const handleSendMessage = async () => {
//     if (!input.trim()) return;

//     setButtonHl(true); // Highlight button when message is being sent

//     const userMessage = {
//       id: Date.now(),
//       sender: 'You',
//       text: input.trim(),
//     };

//     // Clear previous AI messages before adding the new one
//     setMessages((prev) => [
//       ...prev.filter((msg) => msg.sender !== 'AI'),
//       userMessage,
//     ]);

//     setInput('');
//     setButtonHl(false); // Reset button highlight while waiting for AI response
//     setIsTyping(true);

//     try {
//       const response = await fetch('/api/chat', {
//         method: 'POST',
//         headers: {
//           'Content-Type': 'application/json',
//         },
//         body: JSON.stringify({ message: userMessage.text }),
//       });

//       const data = await response.json();

//       if (response.ok) {
//         const botMessage = {
//           id: Date.now() + 1,
//           sender: 'AI',
//           text: data.response,
//         };
//         setMessages((prev) => [...prev, botMessage]);
//       } else {
//         const errorMessage = {
//           id: Date.now() + 1,
//           sender: 'AI',
//           text: data.error || 'Something went wrong.',
//         };
//         setMessages((prev) => [...prev, errorMessage]);
//       }
//     } catch (error) {
//       console.error('Error fetching chat:', error);
//       const errorMessage = {
//         id: Date.now() + 1,
//         sender: 'AI',
//         text: 'An unexpected error occurred.',
//       };
//       setMessages((prev) => [...prev, errorMessage]);
//     } finally {
//       setIsTyping(false);
//     }
//   };

//   const handleCopyChat = () => {
//     const chatContent = chatContainerRef.current?.innerText;
//     if (chatContent) {
//       navigator.clipboard
//         .writeText(chatContent)
//         .then(() => alert('Chat copied to clipboard!'))
//         .catch((err) => console.error('Failed to copy: ', err));
//     }
//     setIsCopied(true);
//     setCopyHover(false);

//     setTimeout(() => setIsCopied(false), 2000);
//   };

//   const handleCopyMouseOver = () => {
//     if (!isCopied) {
//       setCopyHover(true);
//     }
//   };

//   const handleCopyMouseOut = () => {
//     setCopyHover(false);
//   };

//   const handleCopyMouseDown = () => {
//     setCopyHover(false);
//   };

//   const handleRefreshChat = async () => {
//     const lastUserMessage = messages
//       .slice()
//       .reverse()
//       .find((msg) => msg.sender === 'You');
  
//     if (!lastUserMessage) return;
  
//     // Clear previous AI messages before adding the refreshed one
//     setMessages((prev) => prev.filter((msg) => msg.sender !== 'AI'));
  
//     setIsTyping(true);
  
//     try {
//       const response = await fetch('/api/chat', {
//         method: 'POST',
//         headers: {
//           'Content-Type': 'application/json',
//         },
//         body: JSON.stringify({ message: lastUserMessage.text }),
//       });
  
//       const data = await response.json();
  
//       if (response.ok) {
//         const refreshedMessage = {
//           id: Date.now(),
//           sender: 'AI',
//           text: data.response,
//         };
  
//         setMessages((prev) => [
//           ...prev.filter((msg) => msg.sender !== 'AI'),
//           refreshedMessage,
//         ]);
//       } else {
//         const errorMessage = {
//           id: Date.now(),
//           sender: 'AI',
//           text: data.error || 'Something went wrong while refreshing.',
//         };
  
//         setMessages((prev) => [
//           ...prev.filter((msg) => msg.sender !== 'AI'),
//           errorMessage,
//         ]);
//       }
//     } catch (error) {
//       console.error('Error refreshing chat:', error);
//       const errorMessage = {
//         id: Date.now(),
//         sender: 'AI',
//         text: 'An unexpected error occurred while refreshing.',
//       };
  
//       setMessages((prev) => [
//         ...prev.filter((msg) => msg.sender !== 'AI'),
//         errorMessage,
//       ]);
//     } finally {
//       setIsTyping(false);
//     }
//   };

//   const formatBlogContent = (content) => {
//     const cleanedContent = content;

//       // Title
//       const titleMatch = cleanedContent.match(
//         /^## Blog:\s*\*\*(.*?)\*\*|^##\s*Blog:\s*(.*?)$|^##\s?\*\*(.*?)\*\*|\*\*Blog:\s*(.*?)\*\*/m
//       );
      
//       let BlogTitle = "";
//       if (titleMatch) {
//         BlogTitle = titleMatch[1] || titleMatch[2] || titleMatch[3] || titleMatch[4] || "";
//       }
//       const formattedTitle = BlogTitle
//         ? `<h1 class="heading1">${BlogTitle.trim()}</h1>`
//         : "";


//     // Paragraph
//         const introMatch = cleanedContent.match(/\*\*Introduction:\*\*\s*([\s\S]*?)(?=\s\*\*|$)/);
//         const paragraph = introMatch ? `<p class="para-text">${introMatch[1].trim()}</p>` : "";
        

//       const formattedContent = cleanedContent
//           .replace(/^## Blog:\s*\*\*(.*?)\*\*/gm, '<h1 class="heading1">$1</h1>') //for ##Blog: **.....**
//           .replace(/^##\s*Blog:\s*(.*?)$/gm, '<h1 class="heading1">$1</h1>') //for ##Blog:
//           .replace(/^##\s?\*\*(.*?)\*\*/gm, '<h1 class="heading1">$1</h1>') //for ##**.....**
//           .replace(/^###\s?\*\*(.*?)\*\*/gm, '<h2 class="heading2an">$1</h2>') //for ###**.....**
//           .replace(/^###\s*(.*?)\s*$/gm, '<h2 class="heading2an">$1</h2>') // for ###....
//           .replace(/^##\s*(.*?)\s*$/gm, '<h2 class="heading2an">$1</h2>') // for ##....
//           .replace(/\*\*Blog:\s*(.*?)\*\*/g, '<h1 class="heading1">$1</h1>')//for **Blog:....**

//           .replace(/\*\s\*\*(.*?)\*\*\:/g, '<h4 class="heading3">$1:</h4>') //for * **...**
//           .replace(/\-\s\*\*(.*?)\*\*\:/g, '<h4 class="heading3">$1:</h4>') //for - **...**
//           .replace(/\*\s\*\*(.*?)\*\*/g, '<h4 class="heading3">$1</h4>') //for * **...**
//           .replace(/\-\s\*\*(.*?)\*\*/g, '<h4 class="heading3">$1</h4>') //for - **...**
//           .replace(/\*\*(.*?)\*\*/g, '<h2 class="heading2">$1</h2>') //for **.....**
//           .replace(/^([*-])\s(.*?)(?=\n|$)/gm, '<li class="list-item">$2</li>') 

//           .replace(/^(?!<h1|<h2)(.*?)(?=\n|$)/gm, '<p class="para-text">$1</p>') 
//           .replace(/\n+/g, '') 
//           .trim();


    
    
  
//     return formattedContent;
//   };

//   // const formatBlogContent = (content) => {
//   //   const cleanedContent = content;
  
//   //   // Title
//   //   const titleMatch = cleanedContent.match(
//   //     /^## Blog:\s*\*\*(.*?)\*\*|^##\s*Blog:\s*(.*?)$|^##\s?\*\*(.*?)\*\*|\*\*Blog:\s*(.*?)\*\*/m
//   //   );
  
//   //   let BlogTitle = "";
//   //   if (titleMatch) {
//   //     BlogTitle = titleMatch[1] || titleMatch[2] || titleMatch[3] || titleMatch[4] || "";
//   //   }
//   //   const formattedTitle = BlogTitle
//   //     ? `<h1 class="heading1">${BlogTitle.trim()}</h1>`
//   //     : "";
  
//   //   // Paragraph
//   //   const introMatch = cleanedContent.match(
//   //     /\*\*Introduction:\*\*\s*([\s\S]*?)(?=\s\*\*|$)|^###\s*Introduction\s*([\s\S]*?)(?=\s\*\*|^##|\n|$)/
//   //   );
//   //   let BlogPara = "";
//   //   if (introMatch) {
//   //     BlogPara = introMatch[1] || introMatch[2] || introMatch[3] || introMatch[4] || "";
//   //   }
//   //   console.log("PARA",BlogPara);
    
//   //   // Extract the content correctly based on which group was matched
//   //   const paragraph = BlogPara
//   //     ? `<p class="para-text">${BlogPara.trim()}</p>` 
//   //     : "";
    
  
//   //   // Remove formattedTitle and paragraph content from the original content
//   //   let contentWithoutTitleAndParagraph = cleanedContent;
  
//   //   if (formattedTitle) {
//   //     contentWithoutTitleAndParagraph = contentWithoutTitleAndParagraph.replace(titleMatch[0], "");
//   //   }
//   //   if (paragraph) {
//   //     contentWithoutTitleAndParagraph = contentWithoutTitleAndParagraph.replace(introMatch[0], "");
//   //   }
  
//   //   // Format the remaining content
//   //   const formattedContent = contentWithoutTitleAndParagraph
//   // .replace(/^###\s?\*\*(.*?)\*\*/gm, '<h2 class="heading2an">$1</h2>') //for ###**.....**

//   //     .replace(/^###\s*(.*?)\s*$/gm, '<h2 class="heading2an">$1</h2>') // for ###....
//   //     .replace(/^##\s*(.*?)\s*$/gm, '<h2 class="heading2an">$1</h2>') // for ##....
//   //     .replace(/\*\s\*\*(.*?)\*\*\:/g, '<h4 class="heading3">$1:</h4>') // for * **...
//   //     .replace(/\-\s\*\*(.*?)\*\*\:/g, '<h4 class="heading3">$1:</h4>') // for - **...
//   //     .replace(/\*\s\*\*(.*?)\*\*/g, '<h4 class="heading3">$1</h4>') // for * **...
//   //     .replace(/\-\s\*\*(.*?)\*\*/g, '<h4 class="heading3">$1</h4>') // for - **...
//   //     .replace(/\*\*(.*?)\*\*/g, '<h2 class="heading2">$1</h2>') // for **.....
//   //     .replace(/^([*-])\s(.*?)(?=\n|$)/gm, '<li class="list-item">$2</li>') 
//   //     .replace(/^(?!<h1|<h2)(.*?)(?=\n|$)/gm, '<p class="para-text">$1</p>') // Paragraph tag for other content
//   //     .replace(/\n+/g, "") // Remove extra line breaks
//   //     .trim();
  
//   //   // Return formattedTitle, paragraph, and the rest of the formatted content
//   //   return { formattedTitle, paragraph, formattedContent };
//   // };
  
  

//   return (
//      <div className="prfec-ai">
//       <div className="prfec-ai-container">
//         {/* AI Dashboard Section */}
//         <div className="ai-dashboard">
//           <div className="ai-dashboard-container">
//             <div className="ai-dashboard-contents">
//               <div className="ai-dashboard-title">
//                 <label htmlFor="">Title</label>
//                 <input type="text" />
//               </div>
//               <div className="ai-dashboard-description">
//                 <label htmlFor="">Meta description</label>
//                 <input type="text" />
//               </div>
//               <div className="ai-dashboard-body">
//                 <label htmlFor="">Body</label>
//                 <input type="text" />
//               </div>
//               <div className="ai-dashboard-category">
//                 <label htmlFor="">Category</label>
//                 <input type="text" />
//               </div>
//               <div className="ai-dashboard-category">
//                 <label htmlFor="">Keyword</label>
//                 <input type="text" />
//               </div>
//             </div>
//           </div>
//         </div>

//         <div className="chat-space">
//           <div className="chat-container" ref={chatContainerRef}>
//             {messages
//               .filter((msg) => msg.sender === 'AI')
//               .map((msg, index) => (
//                 <p
//                   key={index}
//                   className="para-text ai-message"
//                   dangerouslySetInnerHTML={{
//                     __html: formatBlogContent(msg.text),  // Format the blog content
//                   }}
//                 />
//               ))}

//               {/* {messages
//                 .filter((msg) => msg.sender === 'AI')
//                 .map((msg, index) => {
//                   // Destructure the formattedTitle and paragraph
//                   const { formattedTitle, paragraph,  formattedContent } = formatBlogContent(msg.text);
                  
//                   return (
//                     <div key={index}>
//                       {formattedTitle && (
//                         <h1 className="heading1" dangerouslySetInnerHTML={{ __html: formattedTitle }} />
//                       )}
                      
//                       {paragraph && (
//                         <p className="para-text ai-message" dangerouslySetInnerHTML={{ __html: paragraph }} />
//                       )}

//                       {formattedContent && (
//                         <p className="para-text ai-message" dangerouslySetInnerHTML={{ __html: formattedContent }} />
//                       )}
//                     </div>
//                   );
//                 })} */}


//             {isTyping && (
//               <div className="loading-skeleton ai-message">
//                 <div className="skeleton-line"></div>
//                 <div className="skeleton-line"></div>
//                 <div className="skeleton-line"></div>
//               </div>
//             )}
//           </div>

//           <div className="chat-action-buttons">
//             <div className="copy-chat-button">
//               <Image
//                 src={copy}
//                 width={16}
//                 height={16}
//                 onClick={handleCopyChat}
//                 onMouseOver={handleCopyMouseOver}
//                 onMouseOut={handleCopyMouseOut}
//                 onMouseDown={handleCopyMouseDown}
//               />
//               <div className="chat-button-label">
//                 {!isCopied && copyHover && (
//                   <div className="chat-button-label copy">Copy</div>
//                 )}
//                 {isCopied && (
//                   <div className="chat-button-label copied">Copied</div>
//                 )}
//               </div>
//             </div>
//             <div className="refresh-chat-button">
//               <Image
//                 src={refresh}
//                 height={16}
//                 onClick={handleRefreshChat}
//               />
//             </div>
//           </div>
//         </div>
//       </div>

//       <div className="chat-input">
//           <div className="chat-input-container">
//             <input
//               type="text"
//               value={input}
//               onChange={handleInputChange}
//               onKeyDown={(e) => e.key === 'Enter' && handleSendMessage()}
//               placeholder="Type your message..."
//             />
//             <div style={{ display: 'flex', alignItems: 'center' }} >
//               <Image 
//                 src={buttonHl ? Hover : NoHover} 
//                 alt="Button Icon" 
//                 onClick={handleSendMessage} 
//               />
//             </div>
//           </div>
//       </div>

//     </div>
//   );
// }


// 'use client';
// import { useState, useEffect, useRef } from 'react';
// import '@styles/ai/BetaAi.css';
// import Image from 'next/image';
// import Hover from '@public/Images/ai/hover.svg';
// import NoHover from '@public/Images/ai/nohover.svg';
// import copy from '@public/Images/ai/copy.svg';
// import refresh from '@public/Images/ai/refresh.svg';
// import { metadata } from '@app/layout';

// export default function PuterChat() {
//   const [messages, setMessages] = useState([]);
//   const [input, setInput] = useState('');
//   const [isTyping, setIsTyping] = useState(false);
//   const [buttonHl, setButtonHl] = useState(false);
//   const [isCopied, setIsCopied] = useState(false);
//   const [copyHover, setCopyHover] = useState(false);
//   const [formattedTitle, setFormattedTitle] = useState('');
//   const [metaDescription, setMetaDescription] = useState('');
//   const [formattedContent, setFormattedContent] = useState('');
//   const messagesEndRef = useRef(null);
//   const chatContainerRef = useRef(null);

 
//   useEffect(() => {
//     const lastAiMessage = messages.find((msg) => msg.sender === 'AI');
//     if (lastAiMessage) {
//       const { formattedTitle, paragraph, formattedContent } = formatBlogContent(lastAiMessage.text);
//       setFormattedTitle(formattedTitle);
//       setMetaDescription(paragraph);
//       setFormattedContent(formattedContent); // Set the formatted content state
//     }
//   }, [messages]);

//   const handleInputChange = (event) => {
//     const newInput = event.target.value;
//     setInput(newInput);
//     setButtonHl(newInput.trim() !== ''); // Highlight button if input isn't empty
//   };

//   const handleSendMessage = async () => {
//     if (!input.trim()) return;

//     setButtonHl(true); // Highlight button when message is being sent

//     const userMessage = {
//       id: Date.now(),
//       sender: 'You',
//       text: input.trim(),
//     };

//     // Clear previous AI messages before adding the new one
//     setMessages((prev) => [
//       ...prev.filter((msg) => msg.sender !== 'AI'),
//       userMessage,
//     ]);

//     setInput('');
//     setButtonHl(false); // Reset button highlight while waiting for AI response
//     setIsTyping(true);

//     try {
//       const response = await fetch('/api/chat', {
//         method: 'POST',
//         headers: {
//           'Content-Type': 'application/json',
//         },
//         body: JSON.stringify({ message: userMessage.text }),
//       });

//       const data = await response.json();

//       if (response.ok) {
//         const botMessage = {
//           id: Date.now() + 1,
//           sender: 'AI',
//           text: data.response,
//         };
//         setMessages((prev) => [...prev, botMessage]);
//       } else {
//         const errorMessage = {
//           id: Date.now() + 1,
//           sender: 'AI',
//           text: data.error || 'Something went wrong.',
//         };
//         setMessages((prev) => [...prev, errorMessage]);
//       }
//     } catch (error) {
//       console.error('Error fetching chat:', error);
//       const errorMessage = {
//         id: Date.now() + 1,
//         sender: 'AI',
//         text: 'An unexpected error occurred.',
//       };
//       setMessages((prev) => [...prev, errorMessage]);
//     } finally {
//       setIsTyping(false);
//     }
//   };

//   const handleCopyChat = () => {
//     const chatContent = chatContainerRef.current?.innerText;
//     if (chatContent) {
//       navigator.clipboard
//         .writeText(chatContent)
//         .then(() => alert('Chat copied to clipboard!'))
//         .catch((err) => console.error('Failed to copy: ', err));
//     }
//     setIsCopied(true);
//     setCopyHover(false);

//     setTimeout(() => setIsCopied(false), 2000);
//   };

//   const handleCopyMouseOver = () => {
//     if (!isCopied) {
//       setCopyHover(true);
//     }
//   };

//   const handleCopyMouseOut = () => {
//     setCopyHover(false);
//   };

//   const handleCopyMouseDown = () => {
//     setCopyHover(false);
//   };

//   const handleRefreshChat = async () => {
//     const lastUserMessage = messages
//       .slice()
//       .reverse()
//       .find((msg) => msg.sender === 'You');
  
//     if (!lastUserMessage) return;
  
//     // Clear previous AI messages before adding the refreshed one
//     setMessages((prev) => prev.filter((msg) => msg.sender !== 'AI'));
  
//     setIsTyping(true);
  
//     try {
//       const response = await fetch('/api/chat', {
//         method: 'POST',
//         headers: {
//           'Content-Type': 'application/json',
//         },
//         body: JSON.stringify({ message: lastUserMessage.text }),
//       });
  
//       const data = await response.json();
  
//       if (response.ok) {
//         const refreshedMessage = {
//           id: Date.now(),
//           sender: 'AI',
//           text: data.response,
//         };
  
//         setMessages((prev) => [
//           ...prev.filter((msg) => msg.sender !== 'AI'),
//           refreshedMessage,
//         ]);
//       } else {
//         const errorMessage = {
//           id: Date.now(),
//           sender: 'AI',
//           text: data.error || 'Something went wrong while refreshing.',
//         };
  
//         setMessages((prev) => [
//           ...prev.filter((msg) => msg.sender !== 'AI'),
//           errorMessage,
//         ]);
//       }
//     } catch (error) {
//       console.error('Error refreshing chat:', error);
//       const errorMessage = {
//         id: Date.now(),
//         sender: 'AI',
//         text: 'An unexpected error occurred while refreshing.',
//       };
  
//       setMessages((prev) => [
//         ...prev.filter((msg) => msg.sender !== 'AI'),
//         errorMessage,
//       ]);
//     } finally {
//       setIsTyping(false);
//     }
//   };


 
// const handleRestructureClick = async (type) => {
//   let sentence = type === 'title' ? formattedTitle : type === 'description' ? metaDescription : formattedContent;

//   if (!sentence.trim()) {
//       alert("No content available to regenerate.");
//       return;
//   }

//   try {
//       const response = await fetch('/api/refresh', {
//           method: 'POST',
//           headers: {
//               'Content-Type': 'application/json',
//           },
//           body: JSON.stringify({ sentence }),
//       });

//       const data = await response.json();

//       if (response.ok) {
//           if (type === "title") {
//               setFormattedTitle(`<h1 class="heading1">${data.regeneratedSentence}</h1>`);
//           } else if (type === "description") {
//               setMetaDescription(`<p class="para-text">${data.regeneratedSentence}</p>`);
//           } else {
//               setFormattedContent(data.regeneratedSentence); // Update formattedContent
//           }
//       } else {
//           alert(data.error || "Failed to regenerate the sentence.");
//       }
//   } catch (error) {
//       console.error("Error regenerating sentence:", error);
//       alert("An error occurred while regenerating.");
//   }
// };

// const formatBlogContent = (content) => {
//     const cleanedContent = content;
  
//     // Title
//     const titleMatch = cleanedContent.match(
//       /^## Blog:\s*\*\*(.*?)\*\*|^##\s*Blog:\s*(.*?)$|^##\s?\*\*(.*?)\*\*|\*\*Blog:\s*(.*?)\*\*/m
//     );
  
//     let BlogTitle = "";
//     if (titleMatch) {
//       BlogTitle = titleMatch[1] || titleMatch[2] || titleMatch[3] || titleMatch[4] || "";
//     }
//     const formattedTitle = BlogTitle
//       ? `<h1 class="heading1">${BlogTitle.trim()}</h1>`
//       : "";
  
//     // Paragraph
//     const introMatch = cleanedContent.match(
//       /\*\*Introduction:\*\*\s*([\s\S]*?)(?=\s\*\*|$)|^###\s*Introduction\s*([\s\S]*?)(?=\s\*\*|^##|\n|$)/
//     );
//     let BlogPara = "";
//     if (introMatch) {
//       BlogPara = introMatch[1] || introMatch[2] || introMatch[3] || introMatch[4] || "";
//     }
//     console.log("PARA",BlogPara);
    
//     // Extract the content correctly based on which group was matched
//     const paragraph = BlogPara
//       ? `<p class="para-text">${BlogPara.trim()}</p>` 
//       : "";
    
  
//     // Remove formattedTitle and paragraph content from the original content
//     let contentWithoutTitleAndParagraph = cleanedContent;
  
//     if (formattedTitle) {
//       contentWithoutTitleAndParagraph = contentWithoutTitleAndParagraph.replace(titleMatch[0], "");
//     }
//     if (paragraph) {
//       contentWithoutTitleAndParagraph = contentWithoutTitleAndParagraph.replace(introMatch[0], "");
//     }
  
//     // Format the remaining content
//     const formattedContent = contentWithoutTitleAndParagraph
//       .replace(/^###\s?\*\*(.*?)\*\*/gm, '<h2 class="heading2an">$1</h2>') //for ###**.....**

//       .replace(/^###\s*(.*?)\s*$/gm, '<h2 class="heading2an">$1</h2>') // for ###....
//       .replace(/^##\s*(.*?)\s*$/gm, '<h2 class="heading2an">$1</h2>') // for ##....
//       .replace(/\*\s\*\*(.*?)\*\*\:/g, '<h4 class="heading3">$1:</h4>') // for * **...
//       .replace(/\-\s\*\*(.*?)\*\*\:/g, '<h4 class="heading3">$1:</h4>') // for - **...
//       .replace(/\*\s\*\*(.*?)\*\*/g, '<h4 class="heading3">$1</h4>') // for * **...
//       .replace(/\-\s\*\*(.*?)\*\*/g, '<h4 class="heading3">$1</h4>') // for - **...
//       .replace(/\*\*(.*?)\*\*/g, '<h2 class="heading2">$1</h2>') // for **.....
//       .replace(/^([*-])\s(.*?)(?=\n|$)/gm, '<li class="list-item">$2</li>') 
//       .replace(/^(?!<h1|<h2)(.*?)(?=\n|$)/gm, '<p class="para-text">$1</p>') // Paragraph tag for other content
//       .replace(/\n+/g, "") // Remove extra line breaks
//       .trim();
  
//     // Return formattedTitle, paragraph, and the rest of the formatted content
//     return { formattedTitle, paragraph, formattedContent };
//   };

//   function stripHtmlTags(html) {
//     const div = document.createElement('div');
//     div.innerHTML = html;
//     return div.textContent || div.innerText || '';
//   }
  


//   return (
//      <div className="prfec-ai">
//       <div className="prfec-ai-container">
//         {/* AI Dashboard Section */}
//         <div className="ai-dashboard">
//           <div className="ai-dashboard-container">
//             <div className="ai-dashboard-contents">
//             <div className="ai-dashboard-title">
//                 <label htmlFor="ai-title">Title</label>
//                 <input type="text" id="ai-title" value={stripHtmlTags(formattedTitle)} readOnly />
//                 <div className="refresh-title-button" onClick={() => handleRestructureClick('title')}>
//                   <Image src={refresh} height={16} />
//                 </div>
//               </div>
//               <div className="ai-dashboard-description">
//                 <label htmlFor="ai-description">Meta description</label>
//                 <input type="text" id="ai-description" value={stripHtmlTags(metaDescription)} readOnly />
//                 <div className="refresh-description-button" onClick={() => handleRestructureClick('description')}>
//                   <Image src={refresh} height={16} />
//                 </div>
//               </div>

//               <div className="ai-dashboard-body">
//                 <label htmlFor="">Body</label>
//                 <input type="text" id="ai-content" value={stripHtmlTags(formattedContent)} readOnly  />
//                 <div className="refresh-description-button" onClick={() => handleRestructureClick('content')}>
//                   <Image src={refresh} height={16} />
//                 </div>
//               </div>
//               <div className="ai-dashboard-category">
//                 <label htmlFor="">Category</label>
//                 <input type="text" />
//               </div>
//               <div className="ai-dashboard-category">
//                 <label htmlFor="">Keyword</label>
//                 <input type="text" />
//               </div>
//             </div>
//           </div>
//         </div>

//         <div className="chat-space">
//           <div className="chat-container" ref={chatContainerRef}>

//               {messages
//                 .filter((msg) => msg.sender === 'AI')
//                 .map((msg, index) => {
//                   // Destructure the formattedTitle and paragraph
//                   const { formattedTitle, paragraph,  formattedContent } = formatBlogContent(msg.text);
                  
//                   return (
//                     <div key={index}>
//                       {formattedTitle && (
//                         <h1 className="heading1" dangerouslySetInnerHTML={{ __html: formattedTitle }} />
//                       )}
                      
//                       {paragraph && (
//                         <p className="para-text ai-message" dangerouslySetInnerHTML={{ __html: paragraph }} />
//                       )}

//                       {formattedContent && (
//                         <p className="para-text ai-message" dangerouslySetInnerHTML={{ __html: formattedContent }} />
//                       )}
//                     </div>
//                   );
//                 })}


//             {isTyping && (
//               <div className="loading-skeleton ai-message">
//                 <div className="skeleton-line"></div>
//                 <div className="skeleton-line"></div>
//                 <div className="skeleton-line"></div>
//               </div>
//             )}
//           </div>

//           <div className="chat-action-buttons">
//             <div className="copy-chat-button">
//               <Image
//                 src={copy}
//                 width={16}
//                 height={16}
//                 onClick={handleCopyChat}
//                 onMouseOver={handleCopyMouseOver}
//                 onMouseOut={handleCopyMouseOut}
//                 onMouseDown={handleCopyMouseDown}
//               />
//               <div className="chat-button-label">
//                 {!isCopied && copyHover && (
//                   <div className="chat-button-label copy">Copy</div>
//                 )}
//                 {isCopied && (
//                   <div className="chat-button-label copied">Copied</div>
//                 )}
//               </div>
//             </div>
//             <div className="refresh-chat-button">
//               <Image
//                 src={refresh}
//                 height={16}
//                 onClick={handleRefreshChat}
//               />
//             </div>
//           </div>
//         </div>
//       </div>

//       <div className="chat-input">
//           <div className="chat-input-container">
//             <input
//               type="text"
//               value={input}
//               onChange={handleInputChange}
//               onKeyDown={(e) => e.key === 'Enter' && handleSendMessage()}
//               placeholder="Type your message..."
//             />
//             <div style={{ display: 'flex', alignItems: 'center' }} >
//               <Image 
//                 src={buttonHl ? Hover : NoHover} 
//                 alt="Button Icon" 
//                 onClick={handleSendMessage} 
//               />
//             </div>
//           </div>
//       </div>

//     </div>
//   );
// }



const handleRestructureClick = async (type) => {
  let sentence = type === 'title' ? formattedTitle : type === 'description' ? metaDescription : formattedContent;

  if (!sentence.trim()) {
    alert("No content available to regenerate.");
    return;
  }

  try {
    const response = await fetch('/api/refresh', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ sentence }),
    });

    const data = await response.json();

    if (response.ok) {
      if (type === "title") {
        setFormattedTitle(`<h1 class="heading1">${data.regeneratedSentence}</h1>`);
      } else if (type === "description") {
        setMetaDescription(`<p class="para-text">${data.regeneratedSentence}</p>`);
      } else {
        setFormattedContent(data.regeneratedSentence); // Update formattedContent
      }

      // Update the messages accordingly
      const lastMessage = messages.find((msg) => msg.sender === 'AI');
      if (lastMessage) {
        const { formattedTitle, paragraph, formattedContent } = formatBlogContent(lastMessage.text);
        setMessages((prev) => prev.map((msg) => 
          msg.id === lastMessage.id 
            ? { ...msg, formattedTitle, paragraph, formattedContent } 
            : msg
        ));
      }
    } else {
      alert(data.error || "Failed to regenerate the sentence.");
    }
  } catch (error) {
    console.error("Error regenerating sentence:", error);
    alert("An error occurred while regenerating.");
  }
};




0----------------------------before badge----------------------------------------

'use client';
import { useState, useEffect, useRef } from 'react';
import '@styles/ai/BetaAi.css';
import Image from 'next/image';
import Hover from '@public/Images/ai/hover.svg';
import NoHover from '@public/Images/ai/nohover.svg';
import copy from '@public/Images/ai/copy.svg';
import refresh from '@public/Images/ai/refresh.svg';
import { metadata } from '@app/layout';

export default function PuterChat() {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const [buttonHl, setButtonHl] = useState(false);
  const [isCopied, setIsCopied] = useState(false);
  const [copyHover, setCopyHover] = useState(false);
  const [formattedTitle, setFormattedTitle] = useState('');
  const [metaDescription, setMetaDescription] = useState('');
  const [formattedContent, setFormattedContent] = useState('');
  const [category, setCategory] = useState('');
  const [keyword, setKeyword] = useState('');
  const messagesEndRef = useRef(null);
  const chatContainerRef = useRef(null);

 
  useEffect(() => {
    const lastAiMessage = messages.find((msg) => msg.sender === 'AI');
    if (lastAiMessage) {
      const { formattedTitle, paragraph, formattedContent } = formatBlogContent(lastAiMessage.text);
      setFormattedTitle(formattedTitle);
      setMetaDescription(paragraph);
      setFormattedContent(formattedContent); // Set the formatted content state
    }
  }, [messages]);

  const handleInputChange = (event) => {
    const newInput = event.target.value;
    setInput(newInput);
    setButtonHl(newInput.trim() !== ''); // Highlight button if input isn't empty
  };

  const handleSendMessage = async () => {
    if (!input.trim()) return;

    setButtonHl(true); // Highlight button when message is being sent

    const userMessage = {
      id: Date.now(),
      sender: 'You',
      text: input.trim(),
    };

    // Clear previous AI messages before adding the new one
    setMessages((prev) => [
      ...prev.filter((msg) => msg.sender !== 'AI'),
      userMessage,
    ]);

    setInput('');
    setButtonHl(false); // Reset button highlight while waiting for AI response
    setIsTyping(true);

    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ message: userMessage.text }),
      });

      const data = await response.json();

      if (response.ok) {
        const botMessage = {
          id: Date.now() + 1,
          sender: 'AI',
          text: data.response,
        };
        setMessages((prev) => [...prev, botMessage]);
      } else {
        const errorMessage = {
          id: Date.now() + 1,
          sender: 'AI',
          text: data.error || 'Something went wrong.',
        };
        setMessages((prev) => [...prev, errorMessage]);
      }
    } catch (error) {
      console.error('Error fetching chat:', error);
      const errorMessage = {
        id: Date.now() + 1,
        sender: 'AI',
        text: 'An unexpected error occurred.',
      };
      setMessages((prev) => [...prev, errorMessage]);
    } finally {
      setIsTyping(false);
    }
  };

  const handleCopyChat = () => {
    const chatContent = chatContainerRef.current?.innerText;
    if (chatContent) {
      navigator.clipboard
        .writeText(chatContent)
        .then(() => alert('Chat copied to clipboard!'))
        .catch((err) => console.error('Failed to copy: ', err));
    }
    setIsCopied(true);
    setCopyHover(false);

    setTimeout(() => setIsCopied(false), 2000);
  };

  const handleCopyMouseOver = () => {
    if (!isCopied) {
      setCopyHover(true);
    }
  };

  const handleCopyMouseOut = () => {
    setCopyHover(false);
  };

  const handleCopyMouseDown = () => {
    setCopyHover(false);
  };

  const handleRefreshChat = async () => {
          // Clear the AI Dashboard inputs when refreshing chat
          setFormattedTitle('');
          setMetaDescription('');
          setFormattedContent('');

    const lastUserMessage = messages
      .slice()
      .reverse()
      .find((msg) => msg.sender === 'You');
  
    if (!lastUserMessage) return;
  
    // Clear previous AI messages before adding the refreshed one
    setMessages((prev) => prev.filter((msg) => msg.sender !== 'AI'));
  
    setIsTyping(true);
  
    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ message: lastUserMessage.text }),
      });
  
      const data = await response.json();
  
      if (response.ok) {
        const refreshedMessage = {
          id: Date.now(),
          sender: 'AI',
          text: data.response,
        };
  
        setMessages((prev) => [
          ...prev.filter((msg) => msg.sender !== 'AI'),
          refreshedMessage,
        ]);
      } else {
        const errorMessage = {
          id: Date.now(),
          sender: 'AI',
          text: data.error || 'Something went wrong while refreshing.',
        };
  
        setMessages((prev) => [
          ...prev.filter((msg) => msg.sender !== 'AI'),
          errorMessage,
        ]);
      }
    } catch (error) {
      console.error('Error refreshing chat:', error);
      const errorMessage = {
        id: Date.now(),
        sender: 'AI',
        text: 'An unexpected error occurred while refreshing.',
      };
  
      setMessages((prev) => [
        ...prev.filter((msg) => msg.sender !== 'AI'),
        errorMessage,
      ]);
    } finally {
      setIsTyping(false);
      

    }
  };
  

  const handleRestructureClick = async (type) => {
    let sentence = type === 'title' ? stripHtmlTags(formattedTitle) :
                   type === 'description' ? stripHtmlTags(metaDescription) :
                   stripHtmlTags(formattedContent);
  
    if (!sentence.trim()) {
        alert("No content available to regenerate.");
        return;
    }
  
    // Pass category and keyword to the API
    try {
        const response = await fetch('/api/refresh', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                sentence,
                category,
                keyword,
            }),
        });
  
        const data = await response.json();
  
        if (response.ok) {
            // Update messages to reflect the new content
            setMessages(prevMessages => {
              const updatedMessages = [...prevMessages];
              const lastAiMessageIndex = updatedMessages.findLastIndex(msg => msg.sender === 'AI');
  
              if (lastAiMessageIndex !== -1) {
                  const lastAiMessage = updatedMessages[lastAiMessageIndex];
  
                  // Parse the current message content
                  const { formattedTitle: currentTitle, paragraph: currentParagraph, formattedContent: currentContent } = formatBlogContent(lastAiMessage.text);
  
                  // Create the new message text
                  let newMessageText = lastAiMessage.text;
  
                  if (type === "title") {
                      const newTitle = `## Blog: **${data.regeneratedSentence}**`;
                      newMessageText = newMessageText.replace(/^## Blog:\s*\*\*(.*?)\*\*|^##\s*Blog:\s*(.*?)$|^##\s?\*\*(.*?)\*\*|\*\*Blog:\s*(.*?)\*\*/m, newTitle);
                  } else if (type === "description") {
                      newMessageText = newMessageText.replace(
                          /\*\*Introduction:\*\*\s*([\s\S]*?)(?=\s\*\*|$)|^###\s*Introduction\s*([\s\S]*?)(?=\s\*\*|^##|\n|$)/,
                          `**Introduction:** ${data.regeneratedSentence}`
                      );
                  } else if (type === "content") {
                      const introMatch = newMessageText.match(
                          /\*\*Introduction:\*\*\s*([\s\S]*?)(?=\s\*\*|$)|^###\s*Introduction\s*([\s\S]*?)(?=\s\*\*|^##|\n|$)/
                      );
  
                      if (introMatch) {
                          const introEndIndex = introMatch[0].length;
                          newMessageText = newMessageText.slice(0, introEndIndex) + `\n\n${data.regeneratedSentence}`;
                      }
                  }
  
                  // Update the message with the new text
                  updatedMessages[lastAiMessageIndex] = {
                      ...lastAiMessage,
                      text: newMessageText
                  };
              }
  
              return updatedMessages;
            });
  
            // Update the corresponding state
            if (type === "title") {
                setFormattedTitle(`<h1 class="heading1">${data.regeneratedSentence}</h1>`);
            } else if (type === "description") {
                setMetaDescription(`<p class="para-text">${data.regeneratedSentence}</p>`);
            } else {
                setFormattedContent(data.regeneratedSentence);
            }
        } else {
            alert(data.error || "Failed to regenerate the sentence.");
        }
    } catch (error) {
        console.error("Error regenerating sentence:", error);
        alert("An error occurred while regenerating.");
    }
  };
  

const formatBlogContent = (content) => {
    const cleanedContent = content;
  
    // Title
    // const titleMatch = cleanedContent.match(
    //   /^## Blog:\s*\*\*(.*?)\*\*|^##\s*Blog:\s*(.*?)$|^##\s?\*\*(.*?)\*\*|\*\*Blog:\s*(.*?)\*\*/m
    // );
  
    // let BlogTitle = "";
    // if (titleMatch) {
    //   BlogTitle = titleMatch[1] || titleMatch[2] || titleMatch[3] || titleMatch[4] || "";
    // }
    // const formattedTitle = BlogTitle
    //   ? `<h1 class="heading1">${BlogTitle.trim()}</h1>`
    //   : "";
        const titleMatch = cleanedContent.match(
      /^##\s*(.*?)\s*$|^###\s*(.*?)\s*$|^## Blog:\s*\*\*(.*?)\*\*|^##\s*Blog:\s*(.*?)$|^##\s?\*\*(.*?)\*\*|\*\*Blog:\s*(.*?)\*\*/m
    );
  
    let BlogTitle = "";
    if (titleMatch) {
      BlogTitle = titleMatch[1] || titleMatch[2] || titleMatch[3] || titleMatch[4] ||titleMatch[5] ||titleMatch[6] || "";
    }

    const formattedTitle = BlogTitle
      ? `<h1 class="heading1">${BlogTitle.trim()}</h1>`
      : "";
  
    // Paragraph
    // const introMatch = cleanedContent.match(
    //   /\*\*Introduction:\*\*\s*([\s\S]*?)(?=\s\*\*|$)|^###\s*Introduction\s*([\s\S]*?)(?=\s\*\*|^##|\n|$)/
    // );
    // let BlogPara = "";
    // if (introMatch) {
    //   BlogPara = introMatch[1] || introMatch[2] || introMatch[3] || introMatch[4] || "";
    // }
    // console.log("PARA",BlogPara);
    
    // // Extract the content correctly based on which group was matched
    // const paragraph = BlogPara
    //   ? `<p class="para-text">${BlogPara.trim()}</p>` 
    //   : "";
    const introMatch = cleanedContent.match(
      /^([\s\S]*?)(?=\s*\*\*|\n\*\*|$)|\*\*Introduction:\*\*\s*([\s\S]*?)(?=\s\*\*|$)|^###\s*Introduction\s*([\s\S]*?)(?=\s\*\*|^##|\n|$)/
    );

    let BlogPara = "";

    if (introMatch) {
      BlogPara = introMatch[1] || introMatch[2] || introMatch[3] || introMatch[4] ||introMatch[5] || "";
    }
    if (formattedTitle && BlogPara.includes(BlogTitle)) {
      BlogPara = BlogPara.replace(BlogTitle, "").trim();
    }

    const paragraph = BlogPara
      ? `<p class="para-text">${BlogPara.replace(/##/g, '').trim()}</p>` 
      : "";
  
    
  
    // Remove formattedTitle and paragraph content from the original content
    let contentWithoutTitleAndParagraph = cleanedContent;
    if (paragraph) {
      contentWithoutTitleAndParagraph = contentWithoutTitleAndParagraph.replace(introMatch[0], "");
    }
    if (formattedTitle) {
      contentWithoutTitleAndParagraph = contentWithoutTitleAndParagraph.replace(titleMatch[0], "");
    }

  
    // Format the remaining content
    const formattedContent = contentWithoutTitleAndParagraph
      .replace(/^###\s?\*\*(.*?)\*\*/gm, '<h2 class="heading2an">$1</h2>') //for ###**.....**

      .replace(/^###\s*(.*?)\s*$/gm, '<h2 class="heading2an">$1</h2>') // for ###....
      .replace(/^##\s*(.*?)\s*$/gm, '<h2 class="heading2an">$1</h2>') // for ##....
      .replace(/\*\s\*\*(.*?)\*\*\:/g, '<h4 class="heading3">$1:</h4>') // for * **...
      .replace(/\-\s\*\*(.*?)\*\*\:/g, '<h4 class="heading3">$1:</h4>') // for - **...
      .replace(/\*\s\*\*(.*?)\*\*/g, '<h4 class="heading3">$1</h4>') // for * **...
      .replace(/\-\s\*\*(.*?)\*\*/g, '<h4 class="heading3">$1</h4>') // for - **...
      .replace(/\*\*(.*?)\*\*/g, '<h2 class="heading2">$1</h2>') // for **.....
      .replace(/^([*-])\s(.*?)(?=\n|$)/gm, '<li class="list-item">$2</li>') 
      .replace(/^(?!<h1|<h2)(.*?)(?=\n|$)/gm, '<p class="para-text">$1</p>') // Paragraph tag for other content
      .replace(/\n+/g, "") // Remove extra line breaks
      .trim();
  
    // Return formattedTitle, paragraph, and the rest of the formatted content
    return { formattedTitle, paragraph, formattedContent };
  };

  function stripHtmlTags(html) {
    const div = document.createElement('div');
    div.innerHTML = html;
    return div.textContent || div.innerText || '';
  }
  const handleRegenerateWithCategoryAndKeyword = async () => {
    if (!category.trim() || !keyword.trim()) {
      alert('Please provide both category and keyword!');
      return;
    }
  
    const lastUserMessage = messages
      .slice()
      .reverse()
      .find((msg) => msg.sender === 'You');
    
    if (!lastUserMessage) return;
  
    // Clear previous AI messages before adding the refreshed one
    setMessages((prev) => prev.filter((msg) => msg.sender !== 'AI'));
    
    setIsTyping(true);
  
    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: lastUserMessage.text,
          category,
          keyword,
        }),
      });
  
      const data = await response.json();
  
      if (response.ok) {
        const regeneratedMessage = {
          id: Date.now(),
          sender: 'AI',
          text: data.response,
        };
  
        setMessages((prev) => [...prev, regeneratedMessage]);
      } else {
        const errorMessage = {
          id: Date.now() + 1,
          sender: 'AI',
          text: data.error || 'Failed to regenerate content with category and keyword.',
        };
        setMessages((prev) => [...prev, errorMessage]);
      }
    } catch (error) {
      console.error('Error regenerating content:', error);
      const errorMessage = {
        id: Date.now() + 1,
        sender: 'AI',
        text: 'An unexpected error occurred while regenerating.',
      };
      setMessages((prev) => [...prev, errorMessage]);
    } finally {
      setIsTyping(false);
    }
  };
  

  const handleCategoryChange = (event) => {
    setCategory(event.target.value);
  };

  const handleKeywordChange = (event) => {
    setKeyword(event.target.value);
  };

  return (
     <div className="prfec-ai">
      <div className="prfec-ai-container">
        {/* AI Dashboard Section */}
        <div className="ai-dashboard">
          <div className="ai-dashboard-container">
            <div className="ai-dashboard-contents">
            <div className="ai-dashboard-title">
                <label htmlFor="ai-title">Title</label>
                <input type="text" id="ai-title" value={stripHtmlTags(formattedTitle)} readOnly />
                <div className="refresh-title-button" onClick={() => handleRestructureClick('title')}>
                  <Image src={refresh} height={16} />
                </div>
              </div>
              <div className="ai-dashboard-description">
                <label htmlFor="ai-description">Meta description</label>
                <input type="text" id="ai-description" value={stripHtmlTags(metaDescription)} readOnly />
                <div className="refresh-description-button" onClick={() => handleRestructureClick('description')}>
                  <Image src={refresh} height={16} />
                </div>
              </div>

              <div className="ai-dashboard-body">
                <label htmlFor="">Body</label>
                <input type="text" id="ai-content" value={stripHtmlTags(formattedContent)} readOnly  />
                <div className="refresh-description-button" onClick={() => handleRestructureClick('content')}>
                  <Image src={refresh} height={16} />
                </div>
              </div>
              <div className="ai-dashboard-category">
                <label htmlFor="category">Category</label>
                <input
                  type="text"
                  id="category"
                  value={category}
                  onChange={handleCategoryChange}
                />
              </div>
              <div className="ai-dashboard-category">
                <label htmlFor="keyword">Keyword</label>
                <input
                  type="text"
                  id="keyword"
                  value={keyword}
                  onChange={handleKeywordChange}
                />
              </div>
              {/* Submit Button to Regenerate Blog with Category and Keyword */}
              <button
                className="regenerate-button"
                onClick={handleRegenerateWithCategoryAndKeyword}
              >
                Regenerate Blog with Category & Keyword
              </button>

            </div>
          </div>
        </div>

        <div className="chat-space">
          <div className="chat-container" ref={chatContainerRef}>

          {messages
            .filter((msg) => msg.sender === 'AI')
            .map((msg, index) => {
              const { formattedTitle, paragraph, formattedContent } = formatBlogContent(msg.text);
              
              return (
                <div key={index}>
                  {formattedTitle && (
                    <h1 className="heading1" dangerouslySetInnerHTML={{ __html: formattedTitle }} />
                  )}
                  
                  {paragraph && (
                    <p className="para-text ai-message" dangerouslySetInnerHTML={{ __html: paragraph }} />
                  )}

                  {formattedContent && (
                    <p className="para-text ai-message" dangerouslySetInnerHTML={{ __html: formattedContent }} />
                  )}
                </div>
              );
            })}



            {isTyping && (
              <div className="loading-skeleton ai-message">
                <div className="skeleton-line"></div>
                <div className="skeleton-line"></div>
                <div className="skeleton-line"></div>
              </div>
            )}
          </div>

          <div className="chat-action-buttons">
            <div className="copy-chat-button">
              <Image
                src={copy}
                width={16}
                height={16}
                onClick={handleCopyChat}
                onMouseOver={handleCopyMouseOver}
                onMouseOut={handleCopyMouseOut}
                onMouseDown={handleCopyMouseDown}
              />
              <div className="chat-button-label">
                {!isCopied && copyHover && (
                  <div className="chat-button-label copy">Copy</div>
                )}
                {isCopied && (
                  <div className="chat-button-label copied">Copied</div>
                )}
              </div>
            </div>
            <div className="refresh-chat-button">
              <Image
                src={refresh}
                height={16}
                onClick={handleRefreshChat}
              />
            </div>
          </div>
        </div>
      </div>

      <div className="chat-input">
          <div className="chat-input-container">
            <input
              type="text"
              value={input}
              onChange={handleInputChange}
              onKeyDown={(e) => e.key === 'Enter' && handleSendMessage()}
              placeholder="Type your message..."
            />
            <div style={{ display: 'flex', alignItems: 'center' }} >
              <Image 
                src={buttonHl ? Hover : NoHover} 
                alt="Button Icon" 
                onClick={handleSendMessage} 
              />
            </div>
          </div>
      </div>

    </div>
  );
}





------------------------------------------------------------Decenmber 6----------------------------------------------

'use client';
import { useState, useEffect, useRef } from 'react';
import '@styles/ai/BetaAi.css';
import Image from 'next/image';
import Hover from '@public/Images/ai/hover.svg';
import NoHover from '@public/Images/ai/nohover.svg';
import copy from '@public/Images/ai/copy.svg';
import refresh from '@public/Images/ai/refresh.svg';
import refresh2 from '@public/Images/ai/refresh-dash.svg';
import download from '@public/Images/ai/download.svg';
import prfecBtn from '@public/Images/ai/prfec button.svg';
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';

import { metadata } from '@app/layout';

export default function PuterChat() {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const [buttonHl, setButtonHl] = useState(false);
  const [isCopied, setIsCopied] = useState(false);
  const [copyHover, setCopyHover] = useState(false);
  const [formattedTitle, setFormattedTitle] = useState('');
  const [metaDescription, setMetaDescription] = useState('');
  const [formattedContent, setFormattedContent] = useState('');
  const [category, setCategory] = useState('');
  const [keyword, setKeyword] = useState('');
  const [categoryBadges, setCategoryBadges] = useState([]); // State for category badges
  const [keywordBadges, setKeywordBadges] = useState([]);
  const messagesEndRef = useRef(null);
  const chatContainerRef = useRef(null);

 
  // useEffect(() => {
  //   const lastAiMessage = messages.find((msg) => msg.sender === 'AI');
  //   if (lastAiMessage) {
  //     const { formattedTitle, paragraph, formattedContent } = formatBlogContent(lastAiMessage.text);
  //     setFormattedTitle(formattedTitle);
  //     setMetaDescription(paragraph);
  //     setFormattedContent(formattedContent); // Set the formatted content state
  //   }
  // }, [messages]);

  useEffect(() => {
    const lastAiMessage = messages.find((msg) => msg.sender === 'AI');
    if (lastAiMessage) {
      const { formattedTitle: newTitle, paragraph: newDescription, formattedContent: newContent } = formatBlogContent(lastAiMessage.text);
  
      // Update state only if it's different
      if (newTitle && newTitle !== formattedTitle) setFormattedTitle((prev) => prev || newTitle);
      if (newDescription && newDescription !== metaDescription) setMetaDescription((prev) => prev || newDescription);
      if (newContent && newContent !== formattedContent) setFormattedContent((prev) => prev || newContent);
    }
  }, [messages]);



  const handleInputChange = (event) => {
    const newInput = event.target.value;
    setInput(newInput);
    setButtonHl(newInput.trim() !== ''); // Highlight button if input isn't empty
  };

  const handleSendMessage = async () => {
    if (!input.trim()) return;

    setButtonHl(true); // Highlight button when message is being sent

    const userMessage = {
      id: Date.now(),
      sender: 'You',
      text: input.trim(),
    };

    // Clear previous AI messages before adding the new one
    setMessages((prev) => [
      ...prev.filter((msg) => msg.sender !== 'AI'),
      userMessage,
    ]);

    setInput('');
    setButtonHl(false); // Reset button highlight while waiting for AI response
    setIsTyping(true);

    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ message: userMessage.text }),
      });

      const data = await response.json();

      if (response.ok) {
        const botMessage = {
          id: Date.now() + 1,
          sender: 'AI',
          text: data.response,
        };
        setMessages((prev) => [...prev, botMessage]);
      } else {
        const errorMessage = {
          id: Date.now() + 1,
          sender: 'AI',
          text: data.error || 'Something went wrong.',
        };
        setMessages((prev) => [...prev, errorMessage]);
      }
    } catch (error) {
      console.error('Error fetching chat:', error);
      const errorMessage = {
        id: Date.now() + 1,
        sender: 'AI',
        text: 'An unexpected error occurred.',
      };
      setMessages((prev) => [...prev, errorMessage]);
    } finally {
      setIsTyping(false);
    }
  };

  const handleCopyChat = () => {
    const chatContent = chatContainerRef.current?.innerText;
    if (chatContent) {
      navigator.clipboard
        .writeText(chatContent)
        .then(() => alert('Chat copied to clipboard!'))
        .catch((err) => console.error('Failed to copy: ', err));
    }
    setIsCopied(true);
    setCopyHover(false);

    setTimeout(() => setIsCopied(false), 2000);
  };
  const handleDownloadChat = () => {
    const chatContents = document.querySelector('.chat-contents');
    if (!chatContents) return;
    const cleanedTitle = formattedTitle ? stripHtmlTags(formattedTitle) : 'chat-contents';
    const fileName = `${cleanedTitle}.pdf`;

    html2canvas(chatContents).then((canvas) => {
      const imgData = canvas.toDataURL('image/png');
      const pdf = new jsPDF('p', 'mm', 'a4'); // Portrait, millimeters, A4 size
  
      const pdfWidth = pdf.internal.pageSize.getWidth();
      const pdfHeight = (canvas.height * pdfWidth) / canvas.width;
  
      pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
      pdf.save(fileName);
    });
  };
  
  const handleCopyMouseOver = () => {
    if (!isCopied) {
      setCopyHover(true);
    }
  };

  const handleCopyMouseOut = () => {
    setCopyHover(false);
  };

  const handleCopyMouseDown = () => {
    setCopyHover(false);
  };

  const handleRefreshChat = async () => {
          // Clear the AI Dashboard inputs when refreshing chat
          setFormattedTitle('');
          setMetaDescription('');
          setFormattedContent('');

    const lastUserMessage = messages
      .slice()
      .reverse()
      .find((msg) => msg.sender === 'You');
  
    if (!lastUserMessage) return;
  
    // Clear previous AI messages before adding the refreshed one
    setMessages((prev) => prev.filter((msg) => msg.sender !== 'AI'));
  
    setIsTyping(true);
  
    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ message: lastUserMessage.text }),
      });
  
      const data = await response.json();
  
      if (response.ok) {
        const refreshedMessage = {
          id: Date.now(),
          sender: 'AI',
          text: data.response,
        };
  
        setMessages((prev) => [
          ...prev.filter((msg) => msg.sender !== 'AI'),
          refreshedMessage,
        ]);
      } else {
        const errorMessage = {
          id: Date.now(),
          sender: 'AI',
          text: data.error || 'Something went wrong while refreshing.',
        };
  
        setMessages((prev) => [
          ...prev.filter((msg) => msg.sender !== 'AI'),
          errorMessage,
        ]);
      }
    } catch (error) {
      console.error('Error refreshing chat:', error);
      const errorMessage = {
        id: Date.now(),
        sender: 'AI',
        text: 'An unexpected error occurred while refreshing.',
      };
  
      setMessages((prev) => [
        ...prev.filter((msg) => msg.sender !== 'AI'),
        errorMessage,
      ]);
    } finally {
      setIsTyping(false);
      

    }
  };

  // const handleRestructureClick = async (type) => {
  //   let sentence = type === 'title' ? stripHtmlTags(formattedTitle) :
  //                  type === 'description' ? stripHtmlTags(metaDescription) :
  //                  stripHtmlTags(formattedContent);
  
  //   if (!sentence.trim()) {
  //       alert("No content available to regenerate.");
  //       return;
  //   }
  
  //   // Pass category and keyword to the API
  //   try {
  //       const response = await fetch('/api/refresh', {
  //           method: 'POST',
  //           headers: {
  //               'Content-Type': 'application/json',
  //           },
  //           body: JSON.stringify({
  //               sentence,
  //               category,
  //               keyword,
  //           }),
  //       });
  
  //       const data = await response.json();
  
  //       if (response.ok) {
  //           // Update messages to reflect the new content
  //           setMessages(prevMessages => {
  //             const updatedMessages = [...prevMessages];
  //             const lastAiMessageIndex = updatedMessages.findLastIndex(msg => msg.sender === 'AI');
  
  //             if (lastAiMessageIndex !== -1) {
  //                 const lastAiMessage = updatedMessages[lastAiMessageIndex];
  
  //                 // Parse the current message content
  //                 const { formattedTitle: currentTitle, paragraph: currentParagraph, formattedContent: currentContent } = formatBlogContent(lastAiMessage.text);
  
  //                 // Create the new message text
  //                 let newMessageText = lastAiMessage.text;
  
  //                 if (type === "title") {
  //                     const newTitle = `## ${data.regeneratedSentence}`;
  //                     newMessageText = newMessageText.replace(
  //                       /^##\s*(.*?)\s*$|^(##\s*Blog:\s*\*\*(.*?)\*\*|##\s*(.*?)|##\s?\*\*(.*?)\*\*)/m, 
  //                       newTitle
  //                     );
  //                   } else if (type === "description") {
  //                     newMessageText = newMessageText.replace(
  //                         /^([\s\S]*?)(?=\s*\*\*|\n\*\*|$)|\*\*Introduction:\*\*\s*([\s\S]*?)(?=\s\*\*|$)|^###\s*Introduction\s*([\s\S]*?)(?=\s\*\*|^##|\n|$)/,
  //                        `${data.regeneratedSentence}`
  //                     );
  //                     console.log("TITLW",formattedTitle);
  //                     console.log("descro",metaDescription);

  //                 } else if (type === "content") {
  //                     const introMatch = newMessageText.match(
  //                         /\*\*Introduction:\*\*\s*([\s\S]*?)(?=\s\*\*|$)|^###\s*Introduction\s*([\s\S]*?)(?=\s\*\*|^##|\n|$)/
  //                     );

  
  //                     if (introMatch) {
  //                         const introEndIndex = introMatch[0].length;
  //                         newMessageText = newMessageText.slice(0, introEndIndex) +` \n\n${data.regeneratedSentence}`;
  //                     }
  //                 }
  
  //                 // Update the message with the new text
  //                 updatedMessages[lastAiMessageIndex] = {
  //                     ...lastAiMessage,
  //                     text: newMessageText
  //                 };
  //             }
  
  //             return updatedMessages;
  //           });
  //           if (type === "title") {
  //               setFormattedTitle(<h1 class="heading1">${data.regeneratedSentence}</h1>);
  //           } else if (type === "description") {
  //               setMetaDescription(<p class="para-text">${data.regeneratedSentence}</p>);

  //           } else {
  //               setFormattedContent(data.regeneratedSentence);
  //           }
  //       } else {
  //           alert(data.error || "Failed to regenerate the sentence.");
  //       }
  //   } catch (error) {
  //       console.error("Error regenerating sentence:", error);
  //       alert("An error occurred while regenerating.");
  //   }
  // };
  
  // const handleRestructureClick = async (type) => {
  //   const sentence = type === 'title' 
  //     ? stripHtmlTags(formattedTitle) 
  //     : type === 'description' 
  //     ? stripHtmlTags(metaDescription) 
  //     : stripHtmlTags(formattedContent);
  
  //   if (!sentence.trim()) {
  //     alert("No content available to regenerate.");
  //     return;
  //   }
  
  //   try {
  //     const response = await fetch('/api/refresh', {
  //       method: 'POST',
  //       headers: {
  //         'Content-Type': 'application/json',
  //       },
  //       body: JSON.stringify({ sentence, category, keyword }),
  //     });
  
  //     const data = await response.json();
  
  //     if (response.ok) {
  //       const newSentence = data.regeneratedSentence;
  
  //       setMessages((prevMessages) => {
  //         const updatedMessages = [...prevMessages];
  //         const lastAiIndex = updatedMessages.findLastIndex((msg) => msg.sender === 'AI');
  
  //         if (lastAiIndex !== -1) {
  //           const lastMessage = updatedMessages[lastAiIndex];
  //           let updatedText = lastMessage.text;
  
  //           if (type === 'title') {
  //             updatedText = updatedText.replace(/^##\s*(.*?)\s*$/m, `## ${newSentence}`);
  //             setFormattedTitle(newSentence); // Update state separately
  //           } else if (type === 'description') {
  //             updatedText = updatedText.replace(
  //               /\*\*Introduction:\*\*\s*([\s\S]*?)(?=\*\*|$)/,
  //               `**Introduction:** ${newSentence}`
  //             );
  //             setMetaDescription(newSentence);
  //           } else if (type === 'content') {
  //             updatedText += `\n\n${newSentence}`;
  //             setFormattedContent(newSentence);
  //           }
  
  //           updatedMessages[lastAiIndex] = { ...lastMessage, text: updatedText };
  //         }
  
  //         return updatedMessages;
  //       });
  //     } else {
  //       alert(data.error || "Failed to regenerate the sentence.");
  //     }
  //   } catch (error) {
  //     console.error("Error regenerating sentence:", error);
  //     alert("An error occurred while regenerating.");
  //   }
  // };

  const handleRestructureClick = async (type) => {
    const sentence = type === 'title' 
      ? stripHtmlTags(formattedTitle) 
      : type === 'description' 
      ? stripHtmlTags(metaDescription) 
      : stripHtmlTags(formattedContent);
  
    if (!sentence.trim()) {
      alert("No content available to regenerate.");
      return;
    }
  
    try {
      const response = await fetch('/api/refresh', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ sentence, category, keyword }),
      });
  
      const data = await response.json();
  
      if (response.ok) {
        const newSentence = data.regeneratedSentence;
  
        setMessages((prevMessages) => {
          const updatedMessages = [...prevMessages];
          const lastAiIndex = updatedMessages.findLastIndex((msg) => msg.sender === 'AI');
  
          if (lastAiIndex !== -1) {
            const lastMessage = updatedMessages[lastAiIndex];
            let updatedText = lastMessage.text;
  
            if (type === 'title') {
              updatedText = updatedText.replace(/^##\s*(.*?)\s*$/m, `## ${newSentence}`);
              setFormattedTitle(newSentence); // Update state separately
            } else if (type === 'description') {
              updatedText = updatedText.replace(
                /\*\*Introduction:\*\*\s*([\s\S]*?)(?=\*\*|$)/,
                `**Introduction:** ${newSentence}`
              );
              setMetaDescription(newSentence);
            } else if (type === 'content') {
              updatedText += `\n\n${newSentence}`;
              setFormattedContent(newSentence);
            }
  
            updatedMessages[lastAiIndex] = { ...lastMessage, text: updatedText };
          }
  
          return updatedMessages;
        });
      } else {
        alert(data.error || "Failed to regenerate the sentence.");
      }
    } catch (error) {
      console.error("Error regenerating sentence:", error);
      alert("An error occurred while regenerating.");
    }
  };
  
 
const formatBlogContent = (content) => {
    const cleanedContent = content;
  
    //-------------------------------------------------------------------------------------------------- Title
    const titleMatch = cleanedContent.match(
      /^##\s*(.*?)\s*$|^###\s*(.*?)\s*$|^## Blog:\s*\*\*(.*?)\*\*|^##\s*Blog:\s*(.*?)$|^##\s?\*\*(.*?)\*\*|\*\*Blog:\s*(.*?)\*\*/m
    );
   
  
    let BlogTitle = "";
    if (titleMatch) {
      BlogTitle = titleMatch[1] || titleMatch[2] || titleMatch[3] || titleMatch[4] ||titleMatch[5] ||titleMatch[6] || "";
    }

    const formattedTitle = BlogTitle
      ? `<h1 class="heading1">${BlogTitle.trim()}</h1>`
      : "";

    // ------------------------------------------------------------------------------------------------Paragraph

    const introMatch = cleanedContent.match(
      /^([\s\S]*?)(?=\s*\*\*|\n\*\*|$)|\*\*Introduction:\*\*\s*([\s\S]*?)(?=\s\*\*|$)|^###\s*Introduction\s*([\s\S]*?)(?=\s\*\*|^##|\n|$)/
    );

    let BlogPara = "";

    if (introMatch) {
      BlogPara = introMatch[1] || introMatch[2] || introMatch[3] || introMatch[4] ||introMatch[5] || "";
    }
    if (formattedTitle && BlogPara.includes(BlogTitle)) {
      BlogPara = BlogPara.replace(BlogTitle, "").trim();
    }

    const paragraph = BlogPara
      ? `<p class="para-text">${BlogPara.replace(/##/g, '').trim()}</p>` 
      : "";

  // --------------------------------------------------------------------------------------------------------------------------

    let contentWithoutTitleAndParagraph = cleanedContent;
 
    if (paragraph) {
      contentWithoutTitleAndParagraph = contentWithoutTitleAndParagraph.replace(introMatch[0], "");
    }
    if (formattedTitle) {
      contentWithoutTitleAndParagraph = contentWithoutTitleAndParagraph.replace(titleMatch[0], "");
    }

    //------------------------------------------------------------------------------------------------------------------
    const formattedContent = contentWithoutTitleAndParagraph
      .replace(/^###\s?\*\*(.*?)\*\*/gm, '<h2 class="heading2an">$1</h2>') //for ###**.....**
      .replace(/^###\s*(.*?)\s*$/gm, '<h2 class="heading2an">$1</h2>') // for ###....
      .replace(/^##\s*(.*?)\s*$/gm, '<h2 class="heading2an">$1</h2>') // for ##....
      .replace(/\*\s\*\*(.*?)\*\*\:/g, '<h4 class="heading3">$1:</h4>') // for * **...
      .replace(/\-\s\*\*(.*?)\*\*\:/g, '<h4 class="heading3">$1:</h4>') // for - **...
      .replace(/\*\s\*\*(.*?)\*\*/g, '<h4 class="heading3">$1</h4>') // for * **...
      .replace(/\-\s\*\*(.*?)\*\*/g, '<h4 class="heading3">$1</h4>') // for - **...
      .replace(/\*\*(.*?)\*\*/g, '<h2 class="heading2">$1</h2>') // for **.....
      .replace(/^([*-])\s(.*?)(?=\n|$)/gm, '<li class="list-item">$2</li>') 
      .replace(/^(?!<h1|<h2)(.*?)(?=\n|$)/gm, '<p class="para-text">$1</p>') // Paragraph tag for other content
      .replace(/\n+/g, "") // Remove extra line breaks
      .trim();
  
    return { formattedTitle, paragraph, formattedContent };
  };

  function stripHtmlTags(html) {
    const div = document.createElement('div');
    div.innerHTML = html;
    return div.textContent || div.innerText || '';
  }

const handleRegenerateWithCategoryAndKeyword = async () => {
  const fullCategory = [...categoryBadges, category].join(", ");
  const fullKeyword = [...keywordBadges, keyword].join(", ");

  // Ensure both category and keyword are provided
  if (!fullCategory.trim() || !fullKeyword.trim()) {
    alert('Please provide both category and keyword!');
    return;
  }

  const lastUserMessage = messages
    .slice()
    .reverse()
    .find((msg) => msg.sender === 'You');
  
  if (!lastUserMessage) return;

  // Clear previous AI messages before adding the refreshed one
  setMessages((prev) => prev.filter((msg) => msg.sender !== 'AI'));

  setIsTyping(true);

  try {
    const response = await fetch('/api/chat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: lastUserMessage.text,
        category: fullCategory,  // Send combined categories
        keyword: fullKeyword,    // Send combined keywords
      }),
    });

    const data = await response.json();

    if (response.ok) {
      const regeneratedMessage = {
        id: Date.now(),
        sender: 'AI',
        text: data.response,
      };

      setMessages((prev) => [...prev, regeneratedMessage]);
    } else {
      const errorMessage = {
        id: Date.now() + 1,
        sender: 'AI',
        text: data.error || 'Failed to regenerate content with category and keyword.',
      };
      setMessages((prev) => [...prev, errorMessage]);
    }
  } catch (error) {
    console.error('Error regenerating content:', error);
    const errorMessage = {
      id: Date.now() + 1,
      sender: 'AI',
      text: 'An unexpected error occurred while regenerating.',
    };
    setMessages((prev) => [...prev, errorMessage]);
  } finally {
    setIsTyping(false);
  }
};

  const handleCategoryChange = (event) => {
    setCategory(event.target.value);
  };

  const handleKeywordChange = (event) => {
    setKeyword(event.target.value);
  };

  const handleCategoryKeyDown = (event) => {
    if (event.key === 'Enter' && category.trim()) {
      setCategoryBadges((prev) => [...prev, category]);
      setCategory('');
    }
  };

  const handleKeywordKeyDown = (event) => {
    if (event.key === 'Enter' && keyword.trim()) {
      setKeywordBadges((prev) => [...prev, keyword]);
      setKeyword('');
    }
  };

  return (
     <div className="prfec-ai">
      <div className="prfec-ai-container">
        {/* AI Dashboard Section */}
        <div className="ai-dashboard">
          <div className="ai-dashboard-container">
            <h1 className='ai-chat-heading'>AI Content Generation</h1>

            <div className="ai-dashboard-contents">
            <div className="ai-dashboard-title">
                <label htmlFor="ai-title" className='dashboard-label'>Title</label>  
                <div className='ai-dashboard-title-input'>
                  <input type="text" id="ai-title" value={stripHtmlTags(formattedTitle)} readOnly />
                  <div className="refresh-title-button" onClick={() => handleRestructureClick('title')}>
                    <Image src={refresh2} height={12} />
                  </div>
                </div>
              </div>
              <div className="ai-dashboard-description">
                <label htmlFor="ai-description" className='dashboard-label'>Meta description</label>
                <div className='ai-dashboard-title-input'>
                  <input type="text" id="ai-description" value={stripHtmlTags(metaDescription)} readOnly />
                  <div className="refresh-description-button" onClick={() => handleRestructureClick('description')}>
                    <Image src={refresh2} height={12} />
                  </div>
                </div>
              </div>

              <div className="ai-dashboard-body">
                <label htmlFor="" className='dashboard-label'>Body</label>
                <div className='ai-dashboard-title-input'>
                  <input type="text" id="ai-content" value={stripHtmlTags(formattedContent)} readOnly  />
                  <div className="refresh-body-button" onClick={() => handleRestructureClick('content')}>
                    <Image src={refresh2} height={12} />
                  </div>
                </div>
              </div>
              <div className="ai-dashboard-category">
                <label htmlFor="category" className='dashboard-label'>Category</label>
                <div className='ai-dashboard-title-input'>
                  <input type="text" id="category" value={category} onChange={handleCategoryChange} onKeyDown={handleCategoryKeyDown} />
                </div>
                {categoryBadges &&
                <div className="badges-container">
                  {categoryBadges.map((badge, index) => (
                    <span key={index} className="badge">
                      {badge}
                    </span>
                  ))}
                </div>}
              </div>
              <div className="ai-dashboard-category">
                <label htmlFor="keyword" className='dashboard-label'>Keyword</label>
                <div className='ai-dashboard-title-input'>
                  <input type="text" id="keyword" value={keyword} onChange={handleKeywordChange} onKeyDown={handleKeywordKeyDown} />
                </div>
                {keywordBadges &&
                <div className="badges-container">
                  {keywordBadges.map((badge, index) => (
                    <span key={index} className="badge">
                      {badge}
                    </span>
                  ))}
                </div>}
              </div>

              {/* <button className="regenerate-button" onClick={handleRegenerateWithCategoryAndKeyword}> submit </button> */}

            </div>
          </div>
        </div>

        <div className='content-gen-space'>

          <div className="chat-space">
            <div className="chat-container" ref={chatContainerRef}>
              <div className='chat-contents'>
                  {messages
                    .filter((msg) => msg.sender === 'AI')
                    .map((msg, index) => {
                      const { formattedTitle, paragraph, formattedContent } = formatBlogContent(msg.text);
                      
                      return (
                        <div key={index}>
                          {formattedTitle && (
                            <h1 className="heading1" dangerouslySetInnerHTML={{ __html: formattedTitle }} />
                          )}
                          
                          {paragraph && (
                            <p className="para-text ai-message" dangerouslySetInnerHTML={{ __html: paragraph }} />
                          )}

                          {formattedContent && (
                            <p className="para-text ai-message" dangerouslySetInnerHTML={{ __html: formattedContent }} />
                          )}
                        </div>
                      );
                    })}

                  {isTyping && (
                    <div className="loading-skeleton ai-message">
                      <div className="skeleton-line"></div>
                      <div className="skeleton-line"></div>
                      <div className="skeleton-line"></div>
                    </div>
                  )}

              </div>
            </div>
            <div className="chat-action-buttons">
              <div className="copy-chat-button">
                <Image src={copy}  height={14} onClick={handleCopyChat} />
                <div className="chat-button-label">
                  {isCopied && (
                    <div className="chat-button-label-copied">Copied</div>
                  )}
                </div>
              </div>
              <div className="download-chat-button">
                <Image src={download} height={14}    onClick={() => formattedTitle && handleDownloadChat()} />
              </div>
              <div className="refresh-chat-button">
                <Image src={refresh} height={13} onClick={handleRefreshChat} />
              </div>
            </div>
          </div>

        </div>
      </div>

      <div className="chat-input">
          <div className="chat-input-container">
            <input
              type="text"
              value={input}
              onChange={handleInputChange}
              onKeyDown={(e) => e.key === 'Enter' && handleSendMessage()}
              placeholder="Type your message..."
            />
            <div className='chat-input-generate-button' onClick={handleSendMessage}>
              <p>Generate</p>
              <Image src={prfecBtn}/>
            </div>
            {/* <div style={{ display: 'flex', alignItems: 'center',marginTop:"2px" }} >
              <Image  width={24} height={24} src={buttonHl ? Hover : NoHover}  alt="Button Icon" onClick={handleSendMessage}/>
            </div> */}
          </div>
          </div>
    </div>
  );
}

